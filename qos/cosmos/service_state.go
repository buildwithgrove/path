package cosmos

import (
	"errors"
	"net/http"
	"sync"

	"github.com/pokt-network/poktroll/pkg/polylog"
	sharedtypes "github.com/pokt-network/poktroll/x/shared/types"

	"github.com/buildwithgrove/path/gateway"
	"github.com/buildwithgrove/path/metrics/devtools"
	qosobservations "github.com/buildwithgrove/path/observation/qos"
	"github.com/buildwithgrove/path/protocol"
)

var (
	errNilApplyObservations          = errors.New("ApplyObservations: received nil")
	errNilApplyCosmosSDKObservations = errors.New("ApplyObservations: received nil CosmosSDK observation")
)

// The serviceState struct maintains the expected current state of the CosmosSDK blockchain
// based on the endpoints' responses to different requests.
//
// It is responsible for the following:
//  1. Generate QoS endpoint checks for the hydrator
//  2. Select a valid endpoint for a service request
//  3. Update the stored endpoints from observations.
//  4. Update the stored service state from observations.
type serviceState struct {
	logger polylog.Logger

	// serviceStateLock is a read-write mutex used to synchronize access to this struct
	serviceStateLock sync.RWMutex

	// serviceQoSConfig maintains the QoS configs for this service
	serviceQoSConfig CosmosSDKServiceQoSConfig

	// endpointStore maintains the set of available endpoints and their quality data
	endpointStore *endpointStore

	// perceivedBlockNumber is the perceived current block number
	// based on endpoints' responses to `/status` requests.
	// It is calculated as the maximum of block height reported by
	// any of the endpoints for the service.
	perceivedBlockNumber uint64
}

/* -------------------- QoS Endpoint Check Generator -------------------- */

// serviceState provides the endpoint check generator required by
// the gateway package to augment endpoints' quality data,
// using synthetic service requests.
var _ gateway.QoSEndpointCheckGenerator = &serviceState{}

// GetRequiredQualityChecks returns the list of quality checks required for an endpoint.
// It is called in the `gateway/hydrator.go` file on each run of the hydrator.
func (ss *serviceState) GetRequiredQualityChecks(endpointAddr protocol.EndpointAddr) []gateway.RequestQoSContext {
	ss.endpointStore.endpointsMu.RLock()
	defer ss.endpointStore.endpointsMu.RUnlock()

	endpoint := ss.endpointStore.endpoints[endpointAddr]

	// Get the RPC types supported by the CosmosSDK service.
	rpcTypes := ss.serviceQoSConfig.getRPCTypes()

	// List of all checks required for the endpoint.
	var checks []gateway.RequestQoSContext

	// If the service supports CometBFT, add the CometBFT endpoint checks.
	if _, ok := rpcTypes[sharedtypes.RPCType_COMET_BFT]; ok {
		checks = append(checks, ss.getCometBFTEndpointChecks(&endpoint)...)
	}

	// TODO_NEXT(@commoddity): Add endpoint checks for the following:
	//
	//  1. CosmosSDK URL paths (sharedtypes.RPCType_REST):
	//     - Node Info (/cosmos/base/tendermint/v1beta1/node_info)
	//     https://docs.cosmos.network/api#tag/Service/operation/GetNodeInfo
	//     - Syncing Status (/cosmos/base/tendermint/v1beta1/syncing)
	//     https://docs.cosmos.network/api#tag/Service/operation/GetSyncing
	//
	//  2. JSON-RPC methods (sharedtypes.RPCType_JSON_RPC):
	//     - `{"jsonrpc":"2.0","method":"eth_chainId","params":[],"id":1}`
	//     - `{"jsonrpc":"2.0","method":"eth_blockNumber","params":[],"id":1}`

	return checks
}

// getCometBFTEndpointChecks generates the endpoint checks for the CometBFT RPC type.
// API reference: https://docs.cometbft.com/v1.0/rpc/
func (ss *serviceState) getCometBFTEndpointChecks(endpoint *endpoint) []gateway.RequestQoSContext {
	checks := []gateway.RequestQoSContext{}

	// Health check should always run
	if ss.shouldHealthCheckRun(endpoint.checkHealth) {
		checks = append(checks, ss.getEndpointCheckFromHTTPRequest(endpoint.checkHealth.GetRequest()))
	}

	// Status check should always run
	if ss.shouldStatusCheckRun(endpoint.checkStatus) {
		checks = append(checks, ss.getEndpointCheckFromHTTPRequest(endpoint.checkStatus.GetRequest()))
	}

	return checks
}

// getEndpointCheckFromHTTPRequest prepares a request context for a specific endpoint check using an HTTP request.
func (ss *serviceState) getEndpointCheckFromHTTPRequest(httpReq *http.Request) *requestContext {
	return &requestContext{
		logger:       ss.logger,
		serviceState: ss,
		httpReq:      *httpReq,

		// Set the chain and Service ID: this is required to generate observations with the correct chain ID.
		chainID:   ss.serviceQoSConfig.getCosmosSDKChainID(),
		serviceID: ss.serviceQoSConfig.GetServiceID(),
		// Set the origin of the request as Synthetic.
		// The request is generated by the QoS service to collect extra observations on endpoints.
		requestOrigin: qosobservations.RequestOrigin_REQUEST_ORIGIN_SYNTHETIC,
	}
}

// shouldHealthCheckRun returns true if the health check is not yet initialized or has expired.
func (ss *serviceState) shouldHealthCheckRun(check endpointCheckHealth) bool {
	return check.expiresAt.IsZero() || check.IsExpired()
}

// shouldStatusCheckRun returns true if the status check is not yet initialized or has expired.
func (ss *serviceState) shouldStatusCheckRun(check endpointCheckStatus) bool {
	return check.expiresAt.IsZero() || check.IsExpired()
}

/* -------------------- QoS Endpoint State Updater -------------------- */

// ApplyObservations updates endpoint storage and blockchain state from observations.
func (ss *serviceState) ApplyObservations(observations *qosobservations.Observations) error {
	if observations == nil {
		return errNilApplyObservations
	}

	cosmosSDKObservations := observations.GetCosmos()
	if cosmosSDKObservations == nil {
		return errNilApplyCosmosSDKObservations
	}

	updatedEndpoints := ss.endpointStore.updateEndpointsFromObservations(
		cosmosSDKObservations,
	)

	return ss.updateFromEndpoints(updatedEndpoints)
}

// updateFromEndpoints updates the service state based on new observations from endpoints.
// - Only endpoints with received observations are considered.
// - Estimations are derived from these updated endpoints.
func (ss *serviceState) updateFromEndpoints(updatedEndpoints map[protocol.EndpointAddr]endpoint) error {
	ss.serviceStateLock.Lock()
	defer ss.serviceStateLock.Unlock()

	for endpointAddr, endpoint := range updatedEndpoints {
		logger := ss.logger.With(
			"endpoint_addr", endpointAddr,
			"perceived_block_number", ss.perceivedBlockNumber,
		)

		// Do not update the perceived block number if the chain ID is invalid.
		if err := ss.isStatusValid(endpoint.checkStatus); err != nil {
			logger.Error().Err(err).Msgf("❌ Skipping endpoint '%s' with invalid status", endpointAddr)
			continue
		}

		// Retrieve the block number from the endpoint.
		blockNumber, err := endpoint.checkStatus.GetLatestBlockHeight()
		if err != nil {
			logger.Error().Err(err).Msgf("❌ Skipping endpoint '%s' with invalid block height", endpointAddr)
			continue
		}

		// Update perceived block number to maximum instead of overwriting with last endpoint.
		// Per perceivedBlockNumber field documentation, it should be "the maximum of block height reported by any endpoint"
		// but code was incorrectly overwriting with each endpoint, causing validation failures.
		if blockNumber > ss.perceivedBlockNumber {
			logger.Debug().Msgf("Updating perceived block number from %d to %d", ss.perceivedBlockNumber, blockNumber)
			ss.perceivedBlockNumber = blockNumber
		}
	}

	return nil
}

// getDisqualifiedEndpointsResponse gets the QoSLevelDisqualifiedEndpoints map for a devtools.DisqualifiedEndpointResponse.
// It checks the current service state and populates a map with QoS-level disqualified endpoints.
// This data is useful for creating a snapshot of the current QoS state for a given service.
func (ss *serviceState) getDisqualifiedEndpointsResponse(serviceID protocol.ServiceID) devtools.QoSLevelDataResponse {
	qosLevelDataResponse := devtools.QoSLevelDataResponse{
		DisqualifiedEndpoints: make(map[protocol.EndpointAddr]devtools.QoSDisqualifiedEndpoint),
	}

	// Populate the data response object using the endpoints in the endpoint store.
	for endpointAddr, endpoint := range ss.endpointStore.endpoints {
		if err := ss.basicEndpointValidation(endpoint); err != nil {
			qosLevelDataResponse.DisqualifiedEndpoints[endpointAddr] = devtools.QoSDisqualifiedEndpoint{
				EndpointAddr: endpointAddr,
				Reason:       err.Error(),
				ServiceID:    serviceID,
			}

			// DEV_NOTE: if new checks are added to a service, we need to add them here.
			switch {
			// Endpoint is disqualified due to an empty response.
			case errors.Is(err, errEmptyResponseObs):
				qosLevelDataResponse.EmptyResponseCount++

			// Endpoint is disqualified due to a missing or invalid chain ID (status check related).
			case errors.Is(err, errInvalidChainIDObs):
				qosLevelDataResponse.ChainIDCheckErrorsCount++

			// Endpoint is disqualified due to block number issues (status check related).
			case errors.Is(err, errOutsideSyncAllowanceBlockNumberObs):
				qosLevelDataResponse.BlockNumberCheckErrorsCount++

			// Other CosmosSDK-specific errors (health, status, catching up) - not tracked individually
			case errors.Is(err, errNoHealthObs),
				errors.Is(err, errInvalidHealthObs),
				errors.Is(err, errNoStatusObs),
				errors.Is(err, errInvalidStatusObs),
				errors.Is(err, errCatchingUpObs):
				// These are tracked in the DisqualifiedEndpoints map but not counted separately

			default:
				ss.logger.Error().Err(err).Msgf("SHOULD NEVER HAPPEN: unknown error for endpoint: %s", endpointAddr)
			}

			continue
		}
	}

	return qosLevelDataResponse
}
