package router

import (
	"context"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"

	"github.com/pokt-network/poktroll/pkg/polylog/polyzero"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"

	"github.com/buildwithgrove/path/config"
	"github.com/buildwithgrove/path/user"
)

func newTestRouter(t *testing.T, userDataEnabled bool) (*router, *mockGateway, *httptest.Server) {
	mockGateway := newMockGateway(t)

	r := NewRouter(mockGateway, config.RouterConfig{}, userDataEnabled, polyzero.NewLogger())
	ts := httptest.NewServer(r.mux)
	t.Cleanup(ts.Close)

	return r, mockGateway, ts
}

func Test_handleHealthz(t *testing.T) {
	tests := []struct {
		name           string
		expectedStatus int
		expectedBody   string
	}{
		{
			name:           "should return 200 with status ok",
			expectedStatus: http.StatusOK,
			expectedBody:   `{"status":"ok","imageTag":"development"}`,
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			c := require.New(t)

			_, _, ts := newTestRouter(t, false)

			// Create request
			req, err := http.NewRequest("GET", fmt.Sprintf("%s/healthz", ts.URL), nil)
			c.NoError(err)

			// Perform request
			client := &http.Client{}
			resp, err := client.Do(req)
			c.NoError(err)
			defer resp.Body.Close()

			// Test assertions
			c.Equal(test.expectedStatus, resp.StatusCode)

			body, err := io.ReadAll(resp.Body)
			c.NoError(err)
			c.JSONEq(test.expectedBody, string(body))
		})
	}
}

func Test_handleHTTPServiceRequest(t *testing.T) {
	tests := []struct {
		name            string
		userDataEnabled bool
		userAppID       user.UserAppID
		payload         string
		expectedBytes   []byte
		expectedStatus  int
		expectedError   error
	}{
		{
			name:           "should perform a service request successfully",
			payload:        `{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber"}`,
			expectedBytes:  []byte(`{"jsonrpc": "2.0", "id": 1, "result": "0x10d4f"}`),
			expectedStatus: http.StatusOK,
		},
		{
			name:            "should set user app ID in context",
			payload:         `{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber"}`,
			expectedBytes:   []byte(`{"jsonrpc": "2.0", "id": 1, "result": "0x10d4f"}`),
			expectedStatus:  http.StatusOK,
			userDataEnabled: true,
			userAppID:       "user_app_1",
		},
		{
			name:           "should fail if service request handler returns an error",
			payload:        `{"jsonrpc": "2.0", "id": 1, "method": "eth_blockNumber"}`,
			expectedBytes:  []byte("failed to send service request: some error\n"),
			expectedStatus: http.StatusInternalServerError,
			expectedError:  errors.New("some error"),
		},
	}

	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			c := require.New(t)

			_, mockGateway, ts := newTestRouter(t, test.userDataEnabled)

			mockGateway.On("HandleHTTPServiceRequest", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {
				w := args.Get(2).(http.ResponseWriter)
				if test.expectedStatus == http.StatusOK {
					w.WriteHeader(http.StatusOK)
					w.Write(test.expectedBytes)
				} else {
					http.Error(w, "failed to send service request: some error", http.StatusInternalServerError)
				}
			}).Return(test.expectedError)

			url := fmt.Sprintf("%s/v1", ts.URL)
			if test.userDataEnabled {
				url = fmt.Sprintf("%s/v1/%s", ts.URL, test.userAppID)
			}

			req, err := http.NewRequest(http.MethodPost, url, strings.NewReader(test.payload))
			c.NoError(err)

			client := &http.Client{}
			resp, err := client.Do(req)
			c.NoError(err)
			defer resp.Body.Close()

			c.Equal(test.expectedStatus, resp.StatusCode)

			body, err := io.ReadAll(resp.Body)
			c.NoError(err)
			c.Equal(test.expectedBytes, body)
		})
	}
}

// Code below generated by mockery v2.41.0. DO NOT EDIT.

// mockGateway is an autogenerated mock type for the gateway type
type mockGateway struct {
	mock.Mock
}

// HandleHTTPServiceRequest provides a mock function with given fields: ctx, httpReq, w
func (_m *mockGateway) HandleHTTPServiceRequest(ctx context.Context, httpReq *http.Request, w http.ResponseWriter) {
	_m.Called(ctx, httpReq, w)
}

// newMockGateway creates a new instance of mockGateway. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func newMockGateway(t interface {
	mock.TestingT
	Cleanup(func())
}) *mockGateway {
	mock := &mockGateway{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
