services:

  # -------------------- Profile 1: PATH Gateway Only --------------------
  # Run with `make path_up_gateway`
  # Port: 3000
  #
  # This stack runs only the PATH Gateway service, with no auth or
  # other dependencies. This is the simplest way to get PATH running.
  #
  path_gateway:
    container_name: path_gateway
    profiles:
      - path-gateway
    build:
      context: .
      args:
        IMAGE_TAG: ${IMAGE_TAG:-development}
    ports:
      - "3000:3000"
    volumes:
      - ./cmd/.config.yaml:/app/.config.yaml
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:3000/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # -------------------- Profile 2: PATH Entire Stack --------------------
  # Run with `make path_up`
  # Port: 3001
  #
  # This stack runs the PATH Gateway service, with all dependencies.
  # This is the most comprehensive way to get PATH running as it includes
  # authorization and rate limiting for specific PATH gateway endpoints.

  # - Envoy Proxy -
  # This is the Envoy proxy that sits in front of the PATH Gateway Service.
  # All ingress traffic to PATH will first hit the Envoy proxy on port 3001.
  #
  # Request Authorization and Rate Limiting is handled by the Envoy proxy.
  # - Authorization is handled using the `jwt-authn` filter and an external auth service.
  # - Rate limiting is handled by the `ratelimit` container.
  envoy_proxy:
    container_name: envoy_proxy
    image: envoyproxy/envoy:v1.31-latest
    ports:
      - "3001:3001"
    volumes:
      - ./envoy/envoy.yaml:/etc/envoy/envoy.yaml
    # Throw an error if the envoy.yaml file is not found.
    command: /bin/sh -c "if [ ! -f /etc/envoy/envoy.yaml ]; then echo 'envoy.yaml not found. Run `make copy_envoy_config` to generate it.' && exit 1; fi; /usr/local/bin/envoy -c /etc/envoy/envoy.yaml"
    depends_on:
      path:
        condition: service_healthy
    networks:
      - path_network
    ## TODO_IMPROVE: add healthcheck

  # - Envoy External Authorization Service -
  # The Envoy External Authorization Service is used to handle external authorization checks.
  #
  # It is used in conjunction with the Envoy proxy to handle JWT-based authorization.
  ext_authz:
    container_name: ext_authz
    build:
      context: ./envoy/auth_server
      dockerfile: Dockerfile
    env_file:
      - ./envoy/auth_server/.env
    ports:
      - "10003:10003"
    depends_on:
      path:
        condition: service_healthy
      path_auth_data_server:
        condition: service_healthy
    networks:
      - path_network

  # PATH Auth Data Server
  # DEV_NOTE: This is a simple implementation of a gRPC remote server 
  # that handles providing the Envoy External Authorization Service
  # with the necessary information to make an authorization decision.
  # eg. the GatewayEndpoints that should be used for the request.
  #
  # The actual implementation is entirely up to the Gateway operator.
  # This specific implementation just reads data from a static YAML file
  # but in practice it could be implemented however the Gateway operator sees fit.
  # eg. a database lookup, external API call, etc. PATH doesn't know or care.
  path_auth_data_server:
    container_name: path_auth_data_server
    image: ghcr.io/buildwithgrove/path-auth-data-server:latest
    ports:
      - "50051:50051"
    volumes:
      - ./envoy/gateway-endpoints.yaml:/app/gateway-endpoints.yaml
    environment:
      - YAML_FILEPATH=/app/gateway-endpoints.yaml
    networks:
      - path_network
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:50051/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5

  # - Envoy Rate Limiting Service -
  # The Envoy Rate Limiting Service is used to rate limit service requests.
  #
  # It is used in conjunction with the Envoy proxy to handle request rate limiting.
  #
  # It connects to a Redis instance to coordinate rate limit among all services.
  ratelimit:
    container_name: ratelimit
    image: envoyproxy/ratelimit:master
    command: /bin/ratelimit
    expose:
      - "8081"
    volumes:
      - ./envoy/ratelimit.yaml:/data/ratelimit/config/config.yaml
    environment:
      - USE_STATSD=false
      - LOG_LEVEL=error
      - REDIS_SOCKET_TYPE=tcp
      - REDIS_URL=redis:6379
      - RUNTIME_ROOT=/data
      - RUNTIME_SUBDIRECTORY=ratelimit
      - RUNTIME_WATCH_ROOT=false
      - CONFIG_TYPE=FILE
    depends_on:
      path:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - path_network

  # - PATH -
  # This is the main PATH service that handles service requests.
  # It sits behind the Envoy proxy, which handles auth and rate limiting.
  # All ingress traffic to PATH will first hit the Envoy proxy on port 3001.
  # 
  # When run as part of the whole stack, this service does not expose any ports
  # outside of the container. Instead, all traffic is routed through the Envoy proxy.
  path:
    container_name: path
    build:
      context: .
      args:
        IMAGE_TAG: ${IMAGE_TAG:-development}
    expose:
      - "3000"
    volumes:
      - ./cmd/.config.yaml:/app/.config.yaml
    healthcheck:
      test: ["CMD-SHELL", "wget -qO- http://localhost:3000/healthz || exit 1"]
      interval: 30s
      timeout: 10s
      retries: 5
    networks:
      - path_network

  # - Redis Cache -
  # The Redis Cache is used to coordinate rate limiting among all services.
  # It is used in conjunction with the Envoy Rate Limiting Service.
  redis:
    container_name: redis
    image: redis:alpine
    expose:
      - "6379"
    networks:
      - path_network
    healthcheck:
      test: redis-cli ping
      interval: 5s
      retries: 3

# - Docker Network -
networks:
  path_network:
