package main

import (
	"errors"
	"fmt"

	"github.com/pokt-network/poktroll/pkg/polylog"

	"github.com/buildwithgrove/path/config"
	"github.com/buildwithgrove/path/gateway"
	"github.com/buildwithgrove/path/protocol"
)

// setupEndpointHydrator initializes and starts an instance of
// the EndpointHydrator matching the configuration settings.
// The EndpointHydrator will not be started if no
// service QoS generators are specified.
func setupEndpointHydrator(
	logger polylog.Logger,
	protocolInstance gateway.Protocol,
	qosServices map[protocol.ServiceID]gateway.QoSService,
	hydratorConfig config.EndpointHydratorConfig,
) (*gateway.EndpointHydrator, error) {
	if logger == nil {
		return nil, errors.New("no logger provided")
	}

	// This ensures the same QoS instance is used by:
	// 	1. Hydrator: to generate observations on endpoints
	//	2. Gateway: to select endpoints (validated using the observations generated by the Hydrator).
	hydratorQoSServices := make(map[protocol.ServiceID]gateway.QoSService)
	for _, serviceID := range hydratorConfig.ServiceIDs {
		serviceQoS, found := qosServices[serviceID]
		if !found {
			return nil, fmt.Errorf("QoS service not found for service ID: %s", serviceID)
		}

		hydratorQoSServices[serviceID] = serviceQoS
	}

	if len(hydratorQoSServices) == 0 {
		logger.Warn().Msg("endpoint hydrator is fully disabled: no (zero) active service QoS instances are specified")
		return nil, nil
	}

	if protocolInstance == nil {
		return nil, errors.New("endpoint hydrator enabled but no protocol provided. this should never happen")
	}

	endpointHydrator := gateway.EndpointHydrator{
		Logger: logger,

		Protocol:                protocolInstance,
		ActiveQoSServices:       hydratorQoSServices,
		RunInterval:             hydratorConfig.RunInterval,
		MaxEndpointCheckWorkers: hydratorConfig.MaxEndpointCheckWorkers,
	}

	err := endpointHydrator.Start()
	if err != nil {
		return nil, err
	}

	return &endpointHydrator, nil
}
