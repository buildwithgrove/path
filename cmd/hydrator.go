package main

import (
	"errors"
	"fmt"
	"time"

	"github.com/pokt-network/poktroll/pkg/polylog"

	"github.com/buildwithgrove/path/config"
	"github.com/buildwithgrove/path/gateway"
	"github.com/buildwithgrove/path/protocol"
)

// setupEndpointHydrator initializes and starts an instance of
// the EndpointHydrator matching the configuration settings.
// The EndpointHydrator will not be started if no
// service QoS generators are specified.
func setupEndpointHydrator(
	logger polylog.Logger,
	protocolInstance gateway.Protocol,
	qosServices map[protocol.ServiceID]gateway.QoSService,
	metricsReporter gateway.RequestResponseReporter,
	dataReporter gateway.RequestResponseReporter,
	hydratorConfig config.EndpointHydratorConfig,
) (*gateway.EndpointHydrator, error) {
	if logger == nil {
		return nil, errors.New("no logger provided")
	}

	// Wait for the protocol to become healthy before configuring and starting
	// the hydrator. This is necessary to ensure the configured service IDs for
	// the protocol instance and are available in order to start the hydrator.
	waitForProtocolHealth(logger, protocolInstance)

	// Get the configured service IDs from the protocol instance
	// in order to run hydrator checks on all configured service
	// IDs that are not manually disabled by the user.
	configuredServiceIDs := protocolInstance.ConfiguredServiceIDs()

	// Remove any service IDs that are manually disabled by the user.
	// Throw an error if any of the manually disabled service IDs are not found
	// in the protocol's configured service IDs.
	for _, disabledServiceID := range hydratorConfig.QoSDisabledServiceIDs {
		if _, notFound := configuredServiceIDs[disabledServiceID]; notFound {
			return nil, fmt.Errorf("invalid configuration: QoS manually disabled for service ID: %s, but not found in protocol's configured service IDs", disabledServiceID)
		}
		logger.Info().Msgf("QoS manually disabled for service ID: %s", disabledServiceID)
		delete(configuredServiceIDs, disabledServiceID)
	}

	// This ensures the same QoS instance is used by:
	// 	1. Hydrator: to generate observations on endpoints
	//	2. Gateway: to select endpoints (validated using the observations generated by the Hydrator).
	hydratorQoSServices := make(map[protocol.ServiceID]gateway.QoSService)
	for serviceID := range configuredServiceIDs {
		serviceQoS, found := qosServices[serviceID]
		if !found {
			logger.Warn().Msgf("QoS service not found for service ID: %s. NoOp QoS will be used for this service.", serviceID)
			continue
		}

		hydratorQoSServices[serviceID] = serviceQoS
	}

	if len(hydratorQoSServices) == 0 {
		logger.Warn().Msg("endpoint hydrator is fully disabled: no (zero) active service QoS instances are specified")
		return nil, nil
	}

	if protocolInstance == nil {
		return nil, errors.New("endpoint hydrator enabled but no protocol provided. this should never happen")
	}

	endpointHydrator := gateway.EndpointHydrator{
		Logger: logger,

		Protocol:                protocolInstance,
		ActiveQoSServices:       hydratorQoSServices,
		RunInterval:             hydratorConfig.RunInterval,
		MaxEndpointCheckWorkers: hydratorConfig.MaxEndpointCheckWorkers,
		MetricsReporter:         metricsReporter,
		DataReporter:            dataReporter,
	}

	err := endpointHydrator.Start()
	if err != nil {
		return nil, err
	}

	return &endpointHydrator, nil
}

// waitForProtocolHealth blocks until the Protocol reports as healthy.
// This ensures that the hydrator only starts running once the underlying
// protocol layer is ready.
func waitForProtocolHealth(logger polylog.Logger, protocolInstance gateway.Protocol) {
	logger.Info().Msg("waitForProtocolHealth: waiting for protocol to become healthy before starting hydrator")

	for !protocolInstance.IsAlive() {
		logger.Info().Msg("waitForProtocolHealth: protocol not yet healthy, waiting...")
		time.Sleep(1 * time.Second)
	}

	logger.Info().Msg("waitForProtocolHealth: protocol is now healthy, hydrator can proceed")
}
